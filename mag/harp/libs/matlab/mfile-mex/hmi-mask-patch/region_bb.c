#include "mex.h"  /* must appear first */
#include <stdio.h>
#include <math.h>
#include "mexhead.h" /* my mex defines */
#include "Doc/region_bb_docstring.h"  /* autogenerated from this file */

/**************************************************************

%region_bb: find bounding boxes for regions
% 
% [bb]=region_bb(x,coord)
% * The list of bounding boxes of regions in the input map x is
% returned in bb.  
% * x must be Nan, or a nonnegative integer.  Pixels in the 
% range 1..Nr, where Nr is the number of regions, are treated as
% belonging to the corresponding region.
% Inputs x of 0 or NaN are treated as off-region.
% * Each bounding box row is of the form [Lm Ln Um Un] where
% L is the lower corner (in both directions) and U is the
% upper corner diagonal from L.  The "m" (first coordinate) and
% "n" coordinates are given in that order for L and U.  By
% convention, the smallest L = (0,0) and the largest U = (m-1,n-1), 
% but see the coord input.
% * If no pixel in a given region numbered between 1..Nr is found,
% NaN is returned for that row's bounding box.
% * The coord input allows for some coordinate transforms.
% coord(1) is an offset, and coord(2) is a block size.  To get
% standard Matlab coordinates, use [1 1] to add coord(1)=1 to the
% edges.  This is the default: the "conventional" L and U are 
% adjusted before output.
% * The block size is for situations where the pixels were
% averaged from a larger image.  In this case the corners are 
% essentially multiplied by coord(2).  The lowest pixel in the 
% L block and the highest pixel in the U block are given as the 
% bounding box coordinates.
% * This is implemented as a MEX file.
% 
% Inputs:
%   real x(m,n); -- 0, NaN, or 1..Nr
%   opt int coord(1) or coord(2) = [1 1];
% 
% Outputs:
%   int bb(Nr,4);
% 
% See Also:

% turmon may 2001

****************************************************************/
/* Updated by -mex2pymex.py-ver1- on Wed Sep 23 16:55:52 2009 */

/* standard boilerplate */
                   
#define NARGIN_MIN	1	   /* min number of inputs */
#define NARGIN_MAX	2	   /* max number of inputs */
#define NARGOUT_MIN	0	   /* min number of output args */
#define NARGOUT_MAX	1	   /* max number of output args */

#define ARG_x      0   /* x = data */
#define ARG_coord  1   /* coordinate transform */
#define ARG_bb     0   /* bounding boxes */

static const char *progname = "region_bb";
#define PROGNAME region_bb
static const char *in_specs[NARGIN_MAX] = {
  "RM",
  "IS|IV(2)"};
static const char *in_names[NARGIN_MAX] = {
  "x",
  "coord"};
static const char *out_names[NARGOUT_MAX] = {"bb"};

/* default arg */
// defined just for brevity in a generated #include file
#define SHORTNAME rbb

#define Coord_count 2
#define Default_coord_count 2 /* # entries in default */
static double Default_coord[Default_coord_count] = { 1.0, 1.0 };

/****************** Utilities ******************/

/* simple utilities */ 
//#define ActiveLabel(y) ((!isnan(y)) && ((y) > 0)) /* not NaN and not 0 */
#define ActiveLabel(y) ((y) > 0)

/*
 * bb_compute: calculate bounding boxes for each region
 */
static
bb_compute(
	   double **x,    /* input image */
	   double **bb,   /* result: bounding boxes */
	   double *coord, /* coordinate specifier (2 entries) */
	   int Nr,        /* number of regions */
	   int M,         /* dims of image, labeling */
	   int N)

{
  int m, n;      /* loop counters */
  int r;         /* region counter */

  /* set corners to their extreme values */
  for (r = 0; r < Nr; r++) {
    /* note, lower corner is off-image */
    bb[0][r] = M; bb[1][r] = N; /* lower corner: can only move downward */ 
    bb[2][r] = 0; bb[3][r] = 0; /* upper corner: can only move upward */
  }
  for (n = 0; n < N; n++) 
    for (m = 0; m < M; m++) {
      r = x[n][m];
      if (ActiveLabel(r)) {
        /* we are on-object */
	r--; /* make region number (1..Nr) into an index (0..Nr-1) */
	/* move lower corner downward if possible */
	if (m < bb[0][r]) bb[0][r] = m;
	if (n < bb[1][r]) bb[1][r] = n;
	/* move upper corner upward if possible */
	if (m > bb[2][r]) bb[2][r] = m;
	if (n > bb[3][r]) bb[3][r] = n;
      }
    }
  /* coordinate transform of bb */
  for (r = 0; r < Nr; r++) {
    if (bb[0][r] == M) {
      /* still off-image: never found a valid pixel */
      bb[0][r] = bb[1][r] = bb[2][r] = bb[3][r] = mxt_getnand();
      continue;
    }
    /* lower corner */
    bb[0][r] = bb[0][r] * coord[1] + coord[0];
    bb[1][r] = bb[1][r] * coord[1] + coord[0];
    /* upper corner */
    bb[2][r] = (bb[2][r]+1) * coord[1] + coord[0] - 1;
    bb[3][r] = (bb[3][r]+1) * coord[1] + coord[0] - 1;
  }
  return;
}
   

/*
 * Are classes all integers, 0, or NaN?
 */
static
int
count_classes(
	      double *y,
	      int N)
{
  int Nr = 0; /* class count */
  int n; /* counter */

  for (n = 0; n < N; n++)
    if (!isnan(y[n])) {
      if (y[n] < 0 || floor(y[n]) != y[n])
	return(-1);
      if (y[n] > Nr)
	Nr = y[n];
    }
  return(Nr);
}


/*
 * Gateway routine
 */
#ifdef StaticP  /* undefined under mex */
StaticP
#endif
void 
mexFunction(
	    int nlhs, 
	    mxArray *plhs[], 
	    int nrhs,
	    const mxArray *prhs[])
{
  int m, n;           /* size of x */
  double **x2, **bb2; /* 2d indexing */
  int Nr;             /* number of regions found */
  const mxArray *prhs_coord; /*slot for optional coord input argument */
  char errstr[256];

  /* Hook for introspection (function signature, docstring) */
  if (nrhs < 0) { 
    plhs[0] = mxt_PackSignature((mxt_Signature) (-nrhs), 
                                NARGIN_MIN, NARGIN_MAX, 
		      	        NARGOUT_MIN, NARGOUT_MAX, 
                                in_names, in_specs, out_names, docstring);
    return;
  }
  /*
   * check args
   */
  if ((nrhs < NARGIN_MIN) || (nrhs > NARGIN_MAX))
    mexErrMsgTxt((snprintf(errstr, sizeof(errstr),
			   "%s: Expect %d <= input args <= %d",
			   progname, NARGIN_MIN, NARGIN_MAX), errstr));
  if ((nlhs < NARGOUT_MIN) || (nlhs > NARGOUT_MAX))
    mexErrMsgTxt((snprintf(errstr, sizeof(errstr),
			   "%s: Expect %d <= output args <= %d",
			   progname, NARGOUT_MIN, NARGOUT_MAX), errstr));
  mexargparse(nrhs, prhs, in_names, in_specs, NULL, progname);

  /* 
   * fill in optional args
   */
  if (nrhs < (ARG_coord+1))
    prhs_coord = mxCreateDoubleMatrix(0, 0, mxREAL); /* supply empty default */
  else
    prhs_coord = prhs[ARG_coord]; /* use what we were given */

  /*
   * create space for output
   */
  /* 1: find how big it must be */
  m  = mxGetM(prhs[ARG_x]);
  n  = mxGetN(prhs[ARG_x]);

  /* 2: make the space */
  /* first, check x and find #regions */
  if ((Nr = count_classes(mxGetPr(prhs[ARG_x]), m*n)) < 0)
    mexErrMsgTxt((snprintf(errstr, sizeof(errstr),
			 
			  "%s: Regions x must be NaN or nonnegative integers", 
			  progname), errstr));
  /* paradoxically works even if nlhs == 0, in which case strictly
      speaking plhs[0] need not exist (i.e. plhs == NULL in this case)
      MATLAB seems to always have plhs non-null to allow for transmission
      of the result via 'ans' */
  plhs[ARG_bb] = mxCreateDoubleMatrix(Nr, 4, mxREAL); 

  /*
   * do the computation
   */
	     /* set up ordinary 2-d pointers */
  x2  = mxt_make_matrix2(prhs[ARG_x],  -1, -1, 0.0); 
  bb2 = mxt_make_matrix2(plhs[ARG_bb], -1, -1, 0.0);
  bb_compute(x2, bb2,
	     /* coordinate transform argument */
	     mxt_make_vector(prhs_coord, 
			     Coord_count, Default_coord, Default_coord_count),
	     /* sizes */
	     Nr, 
	     m, n);
  /* just frees the array of pointers, not the data they point to */
  mxFree(x2); 
  mxFree(bb2);
}


/* Hook for generic tail matter */
#ifdef MEX2C_TAIL_HOOK
#include "mex2c_tail.h"
#endif

